\chapter{Interfaçage d'Enyo en OCaml}

Pour une adaptation en OCaml d'Enyo, il est nécessaire d'établir une communication
entre les deux langages. Cela présente une première difficulté étant donné le peu
de points communs existants. Nous pouvons néanmoins résoudre le problème en
utilisant  \emph{Js\_of\_ocaml}, un compileur de byte-code OCaml vers Javascript développé par 
l'équipe d'\emph{Ocsigen}. Nous obtenons ainsi un moyen fiable d'assurer une traduction, 
de déclarer des objets Javascript ou encore d'attacher des méthodes à ces derniers, le tout
en restant dans le monde OCaml. La translation assurée, nous pouvons nous concentrer sur 
la modélisation d'Enyo.

Le point critique de l'interfaçage se situe dans l'utilisation des traits 
dynamiques de Javascript, par exemple, utiliser la méthode \emph{setContent(value)} sur un
\emph{kind:"Control"} qui ne possèdera cette méthode qu'après instanciation est
rédibitoire pour une transcription directe en OCaml.\medskip

Après considérations, j'ai choisi de m'arrêter sur un modèle reposant sur une différenciation
d'un objet en construction de celui d'un objet instancié. On représente ainsi un objet \emph{Enyo}
en OCaml grâce aux propriétés le définissant.\medskip

\begin{tikzpicture}[node distance=7cm, auto,]
  \node[punkt] (kind) {Description de l'objet};
  \node[punkt2,right=of kind] (jsobj) {Objet Javascript}
  edge[pil, <-] node[auto]  {Génération et Instanciation} (kind.east);
\end{tikzpicture}
\medskip

L'extension de l'objet en cours de création avec propriétés et méthodes personnalisées est 
abandonné. Cet aspect d'Enyo est nécessaire pour la partie logique de l'application, ce dont 
nous pouvons nous abstraire puisque nous souhaitons un modèle de calcul reposant sur 
un programme OCaml classique.

A partir de là, les objets de l'interface de programmation (API) d'Enyo et leurs méthodes 
sont suffisants si l'on considère utiliser Enyo comme une interface graphique multi-plateforme
pour OCaml. Il est également nécessaire de pouvoir traiter les événements utilisateurs pour bénificier 
d'une interface dynamique et réactive.

Dans un premier temps (\ref{repobj}), nous présenterons la structure choisie, son fonctionnement et les raisons
de cette décision.

Ensuite, la définition des propriétés et leur implémentation (\ref{gestprop})

Enfin, nous nous attarderons sur les événements (\ref{gestevent}).

\section{Représentation des objets}\label{repobj}
\subsection{Modélisation}
D'après le modèle choisi, on distingue donc la représentation en deux types. Le premier,
à créer par l'utilisateur, que nous nommerons ``kind'' par la suite. Et le second,
résultant d'une instanciation, possédant toutes les méthodes décrit dans l'API Enyo, que
nous appellerons ``obj''.

Dans un soucis d'aisance, j'ai fait le choix d'annoter ces ``objets'' à l'aide de types fantômes.
Associés aux variants polymorphes, on profite ainsi d'un sous-typage.
Cela a pour avantage de permettre un partage des noms de méthodes appartenant à plusieurs objets. 
Le désavantage majeur de cette solution reste cependant la confusion liée 
à la génération des messages d'erreurs lors du développement d'une application.

Nous obtenons ainsi les deux types ``kind'' et ``obj'' qui seront utilisés avec l'ensemble de tous 
les type objets Enyo en précisant l'utilisation covariante du paramètre.
\begin{OCaml}
  type any_id = 
        [ `CONTROL | `INPUT | `BUTTON (* | ... *) ]
  type +'a kind (* constraint 'a = [< any_id] *)
  type +'a obj
\end{OCaml}
Les signatures de méthodes partagées prennent alors la forme suivante :
\begin{OCaml}
  sig:
  (*...*)
  
     val setContent : 
         [< `BUTTON | `CONTROL (* ... *) ] obj 
         -> string 
         -> unit
  
  (*...*)
  end
\end{OCaml}

Pour construire l'objet Enyo, ce dernier doit pouvoir contenir:
\begin{itemize}
\item Les propriétés de bases incluent dans l'API Enyo
\item Les fonctions de traitement des différents évenements
\item La liste des sous-composants
\end{itemize}

Le choix s'est donc porté sur une structure de ce type :

\begin{OCaml}
  type handler = Handler of string * (any_id obj -> any_id obj -> any_event obj -> bool)
  type js_value = Int of int | String of string 
                | (*...*) 
                | Array of js_value list 
                | Component of any_id obj 
  type +'a kind = {id:string; 
                   components: any_id kind list; 
                   handler_list:handler list; 
                   prop_list : (string * js_value) list 
                  }
\end{OCaml}

J'incorpore à la structure un champ \emph{id} pour pouvoir permettre une introspection 
sur les futurs objets instanciés (voir \ref{gestevent}).

Quant à la représentation Javascript, elle est simplement représentée par un objet Javascript
du module ``Js.Unsafe'' de la bibliothèque \emph{js\_of\_ocaml}.

\begin{OCaml}
  type +'a obj = Js.Unsafe.any
\end{OCaml}

Cela permet un travail direct sur les différents appels à transmettre au monde Javascript.

Munis des structures, on peut désormais s'intéresser à la construction proprement dite de cette
représentation OCaml d'un objet Enyo.

\subsection{Création}

Pour cette phase de création, j'ai décidé de m'inspirer du module Tk d'OCaml qui utilise les options
pour les fonctions prenant un nombre important d'arguments omissibles.

Plusieurs autres solutions auraient été possible, telle qu'une liste d'association mais dont
je n'ai pas su trouver de façon élégante pour permettre à l'utilisateur de l'employer aisément.

Ainsi, nous obtenons un constructeur, ici de bouton pour l'exemple, de cette forme :

\begin{OCaml}
  val button:
    ?components:any_id kind list
    -> ?content:string
    -> ?showing:bool
    -> ?src:string
    -> ?canGenerate:bool
    (* ... *)
    -> ?ontap:([`BUTTON] obj -> 
               any_id obj -> 
               [`GESTURE] obj -> bool)
    -> unit -> [>`BUTTON] kind
\end{OCaml}

donnant à l'utilisation, pour un bouton contenant un simple label, ceci :

\label{bouton_kind_ex}
\begin{OCaml}
  let mon_bouton = bouton ~content:"Valider" ()
\end{OCaml}

Quelques bémols, cependant, à cette manière de procéder :
\begin{itemize}
\item Le nombre d'arguments de chaque constructeur augmente au fur et à mesure que l'objet
soit profondément situé la hiérarchie,
\item Les messages d'erreurs générés deviennent rapidement indigestes,
\item Une grande redondance parmi les différents constructeurs.
\end{itemize}

Finalement, le code du constructeur revient à inclure chaque argument optionnel passé dans différentes 
listes (typiquement, la liste de propriétés et celle de fonctions de traitement) en testant
au préalable leur existence.
En ajoutant la liste de composants quelques constantes, un ``ID'' pour l'introspection et 
le champ ``kind'' nécéssaire à Enyo, l'objet est prêt à être instancié en tant qu'application 
ou à être passer en tant que sous-élément dans un autre objet par sa liste de ``components''.

\begin{OCaml}
  let button
      ?(components=[])
      ?content
      ?ontap
      (*...*)
      () =
    let prop_list= ref [("kind", String "Button")]
    and handler_list= ref [] in
    (match content with 
        Some v -> prop_list := ("content",String v)
                               ::!prop_list 
        | None -> ());
    (match showing with 
        Some v -> prop_list := ("showing",Bool v)
                               ::!prop_list 
        | None -> ());
    (*...*)
    (match ontap with 
        Some v -> handler_list := Handler ("ontap",v)
                                  ::!handler_list 
        | None -> ());
    {id="BUTTON"; 
     components=components;
     prop_list=(!prop_list);
     handler_list=(!handler_list)}
\end{OCaml}

\subsection{Instanciation}

Après avoir obtenu notre représentation OCaml, il est nécessaire de le traduire en Javascript.
C'est le rôle de la fonction \emph{Instanciate}.

Cette dernière parcourt les différentes listes (propriétés, évenements, et composants) et construit
un objet Javascript formé selon les spécifications d'Enyo que nous passons à \emph{enyo.kind} et 
retournant l'instance de celui-ci avec un nom par défaut si non-fourni.

Une application d'\emph{instanciate} sur le ``bouton kind'' définit plus haut (\ref{bouton_kind_ex}) 
équivaut en Javascript alors à :

\begin{JavaScript}
  enyo.kind({kind:"Button", name:"Default_name", content:"Valider", _onyo_id:"BUTTON"});
  var obj_enyo = new Default_name();
  return obj_enyo;
\end{JavaScript}

La fonction étant relativement indigeste, je détaillerai ici les manipulations éxecutées :

\begin{enumerate}
\item La liste de propriétés est évaluée et chaque type de valeur est traduite si besoin en Javascript.
  Chaque propriété est ensuite injectée dans un nouvel objet Javascript à l'aide de \emph{Js.Unsafe.set}
\item \label{wrap_meth} 
  Les différentes fonctions de traitement présentes sont ``enveloppées'' dans l'objet en tant que méthodes
  dans l'objet avec un appel à \\\emph{Js.wrap\_meth\_callback} prenant une fonction dont le premier argument
  est l'objet lui-même représentant le \emph{this}. Il est aussi nécessaire de déclarer l'objet
  \emph{handlers} pour assurer le traitement des événements.
  (Plus de détails : \ref{gestevent}).
\item Récursion sur tous les sous-composants présents et transformation de la liste de ces derniers en 
  un tableau Javascript à passer au champ ``components'' de l'objet.
\end{enumerate}

Voici, une forme épurée de cette fonction :

\begin{OCaml}
    let instanciate (kind:([< any_id] as 'a) kind) : 'a obj =
      let rec build_component_tree : 'a. ([< any_id] as 'a) kind -> Js.Unsafe.any = fun kind ->
          let js_obj = Js.Unsafe.new_obj (variable "Object") [||]
          in
          (* 1 *)
          ;
          (if kind.handler_list != [] then
              (* 2 *)
          );
          (if kind.components != []  then
              (* 3 *)
              let array_component = Array.of_list (List.map build_component_tree kind.components) in
	      Js.Unsafe.set js_obj "components" (array array_component));
          Js.Unsafe.set js_obj "_onyo_id" (string (kind.id));
          js_obj in
       kind_it (build_component_tree kind)
\end{OCaml}

%Note : il a été nécessaire d'utiliser un quantificateur universel pour unifier la récursion 
%avec la fonction afin d'assurer le polymorphisme\\\medskip

Enfin, on passe cet objet à la fonction \emph{enyo.kind} pour récupérer un objet Enyo
dont les méthodes sont désormais appelables tel que \emph{setContent} si l'objet hérite 
de \emph{Control} dans la hiérarchie Enyo.

L'utilisateur est désormais en mesure d'afficher son application en effectuant un appel
à la méthode \emph{renderInto} (si l'objet en possède la méthode) sur l'objet instancié.

\section{Gestion des propriétés et des méthodes}\label{gestprop}

Pour pouvoir représenter les valeurs Javascript faiblement typées, il a été nécessaire de définir un 
ensemble de ces type valeurs. Un type somme est suffisant :

\begin{OCaml}
    type js_value = Int of int | String of string 
                  | Char of char | Float of float 
                  | Dom_node of dom_node | Bool of bool 
                  | Array of js_value list | Component of any_id obj 
\end{OCaml}

Note: j'ai trouvé préférable de représenter le tableau Javascript sous forme de liste,
le premier étant plus proche de la liste OCaml que du tableau.\medskip

Les propriétés possédés par les objets Enyo sont implémentées en tant que ``Published'' 
(voir \ref{sec:published}). Ces propriétés possèdent donc des accesseurs (get) et des modificateurs (set) ainsi
que la fonction \emph{<valuename>Changed}. Il faut alors pour chaque propriété générer ces méthodes.

J'ai fait le choix d'omettre la possibilité de définir un \emph{<valuename>Changed} qui peut cependant,
si la logique de l'application le nécessite, être remplacé par un simple appel de fonction au moment
de la modification de propriété.

Au niveau de l'implémentation, j'ai ajouté ces accesseurs/modificateurs pour chaque propriété définie 
et appelable par tous les composants en héritant.

Afin d'assurer une bonne traduction Javascript/OCaml, il a fallu selon les types employés traduire
les variables. Pour cela, l'API de ``js\_of\_ocaml'' propose les fonctions nécessaires :

\begin{OCaml}
  val bool : bool -> bool t
  val to_bool : bool t -> bool
  (*...*)
  val array : 'a array -> 'a js_array t
  val to_array : 'a js_array t -> 'a array
\end{OCaml}

Selon le type de la propriété, on s'assure alors d'effectuer correctement cette traduction :

\begin{OCaml}
  let getContent this () =
    let value = Js.Unsafe.meth_call 
                     this 
                     "getContent" 
                     [||] in (* Appel de la methode sur l'objet Javascript *)
    to_string value (* conversion de la valeur js obtenu en valeur caml *)
\end{OCaml}
\clearpage %A vérifier plus tard
\begin{OCaml}
  let setContent this chaine1 =
    let _ = Js.Unsafe.meth_call 
                this 
                "setContent" 
                [|Js.Unsafe.inject (string chaine1)|] in (* conversion caml -> javascript *)
    ()
\end{OCaml}

Les propriétés Enyo étant pour la plupart initialisées par défaut, je n'ai pas jugé urgent
de gérer les cas de valeur ``null''. Il faudrait, pour certains cas, fournir cette sécurité.\medskip

Une autre difficulté s'est posée concernant les méthodes polymorphiques. Une méthode de type
\emph{setProperty(name, value)} est difficile à representer en OCaml, c'est pourquoi j'ai préferé
laisser ce problème de côté afin de ne pas compliquer le typage.

Quelques propriétés ont ainsi été laissées de côté, comme par exemple celles prenant des
objets Javascript non-Enyo en valeur.

\begin{JavaScript}
//bounds : {left: _offsetLeft_, top: _offsetTop_, width: _offsetWidth_, height: _offsetHeight_}
this.setBounds({width: 100, height: 100}, "px");
this.setBounds({left:"100", top:"40", width: "10em", right: "30pt"});
\end{JavaScript}

Il conviendrait d'étudier chaque cas particulier et de fournir une équivalence sûre quitte à
réduire les possibilités d'usage. Par exemple, fournir une fonction à quatre arguments qui
n'agit sur une seule unité de mesure.\medskip

Enfin, certaines propriétés et arguments de méthodes peuvent changer de type selon leur usage 
et il n'est pas toujours agréable d'avoir à effectuer une conversion OCaml (ex: \emph{string\_of\_int})
sur ces appels. Une solution pourrait être de dupliquer ces méthodes, par exemple, en les préfixant 
par le type. Ainsi, la propriété ``value''  de l'objet Enyo \emph{Slideable} prenant un int, qui par ailleurs 
effectue une collision de nom avec celle de l'objet \emph{Input} (voir \ref{chap:idl}), pourrait 
devenir \emph{int\_getInput} s'appliquant à l'objet Slideable et à ses descendants, tandis que \emph{Input}
posséderait une méthode \emph{string\_getInput}.

\section{Gestion des événements}\label{gestevent}
\subsection{Fonctionnement}
Dans Enyo, la spécification des événements et de leur fonctions de traitement gardent toujours la même
forme.

\begin{JavaScript}
  fonctionTraitement: function(emetteur, evenement){
                          //traitement
                          return bool; }
\end{JavaScript}

La fonction attachée prend en paramètres l'émetteur de cet événement, c'est-à-dire, 
le composant qui a genéré ou propagé celui-ci, et l'objet événement lui-même.
Celui-ci retourne un booléen spécifiant si la propagation doit être effectué.
(voir : \ref{sec:event} pour plus de détails)

Pour adapter l'évenement en OCaml, j'ai choisi ce type :
\begin{OCaml}
  type any_event = [`GESTURE (* |  Ensemble des evenements *) ]
  type handler = Handler of string * (any_id obj -> any_id obj -> any_event obj -> bool)
\end{OCaml}

La gestion de l'événement est donc représentée par un couple contenant le nom de l'événement et la 
fonction de traitement associée avec en premier argument le \emph{this} de la méthode (voir : \ref{wrap_meth}).

En informant la signature dans chaque constructeur, il devient aisé de constituer un typage correct.
Ainsi, nous pouvons résoudre le \emph{this} selon l'objet en cours de construction et l'événement attendu.
L'émetteur ne peut cependant pas être résolu, nous y reviendrons plus loin.

Pour un bouton, nous attendrons un argument de ce type :

\begin{OCaml}
  val button:
    (*...*)
    -> ?ontap:([`BUTTON] obj -> any_id obj -> [`GESTURE] obj -> bool)
    -> unit -> [>`BUTTON] kind
\end{OCaml}

A l'utilisation, nous pourrons alors utiliser les méthodes de button sans causer de conflit de type 
puisqu'employé dans un contexte correct :

\begin{OCaml}
let traitement_bouton this emetteur evenement = 
   setContent this "Nouveau contenu";
   setDisabled this true;
   true

let mon_bouton = button ~content:"contenu" ~ontap:traitement_bouton ()
\end{OCaml}

J'ai défini les événements de la même manière que les objets. Il n'est, en revanche, pas nécessaire 
de partager les méthodes appliquables sur les  événements puisqu'ils ne sont pas liés entre eux. Il 
est cependant nécessaire d'affecter à chaque type d'événements des fonctions d'accesseurs pour 
récupérer les informations contenus.

Par exemple, pour l'événement souris, rebaptisé ``gesture'' pour se conformer à Enyo, les accesseurs,
stipulés dans la définition IDL W3C, sont définis :

\begin{OCaml}
  val gesture_screenX : [`GESTURE] obj-> int
  val gesture_screenY : [`GESTURE] obj-> int
  val gesture_identifier : [`GESTURE] obj-> int
  val gesture_detail : [`GESTURE] obj-> int
  (* ... *)
\end{OCaml}
\medskip

\'A l'instanciation d'un objet pourvu d'un événement, il est nécessaire de passer l'événement traité
dans un objet contenu dans le champ \emph{handlers} de celui-ci. Ainsi, le \emph{mon\_bouton} définit plus haut,
aura cette forme en Javascript :

\begin{JavaScript}
  {kind:"Button", handlers:{ontap:"tap"}, 
    tap:function(){ return callback_caml(this) /* gere par js_of_ocaml */ }}
\end{JavaScript}

Cette stratégie permet à chaque composant de posséder sa fonction de traitement mais présente 
un gros soucis lors du ``bubbling'' (remontée d'événement). En effet, il faut pouvoir connaître l'origine
de l'événement à tout moment .

Prenons une situation d'exemple en Enyo avec notre représentation:
\begin{JavaScript}
enyo.kind({
    kind:"Control",
    name:"App",
    components:[
      {kind:"Control",
        components:[
          {kind:"Button", content:"Vert",         
            handlers:{ontap:"tap"},
            tap:function(emetteur, event){
              //emetteur = this 
              return false; //propagation au noeud-parent
            }
          },
          {kind:"Button", content:"Bleu",         
            handlers:{ontap:"tap"},
            tap:function(emetteur, event){
              //emetteur = this
              return false; //propagation au noeud-parent
            }
          }
        ]
        }
      ],
    handlers:{ontap:"tap"},
    tap:function(emetteur, event){
      //emetteur = sous-control
      // change le fond en noir si l'emetteur est b1
      // ou bien en blanc si b2 
      alert(emetteur);
      return true;
    }
})
\end{JavaScript}

Ici, nous voulons, si l'on clique sur l'un des deux boutons, changer la couleur du fond du
``control'' racine selon le bouton cliqué.

Il faut donc pouvoir tester au niveau racine, quelle a été l'origine des événements.
Le problème ici provient de la propagation au composant parent par les boutons.
En effet, l'argument \emph{emetteur} reçu par la racine ne contient pas l'un des deux boutons
mais le ``Control'' intermédiaire par lequel l'événement a transité.

En Enyo, un simple : \emph{emetteur.originator} renverrait le bouton ayant généré l'événement,
et nous permettrait de déterminer la source mais l'implémentation de cette propriété aurait 
peu de sens dans la représentation actuelle puisqu'il impliquerait la présence d'une propriété
originator dans tous les objets manipulé, même en dehors d'un événement.

Une solution à ce problème peut être de conserver, dans son application, une valeur référencé 
contenant l'objet ou l'information nécessaire pour effectuer le traitement souhaité.
Je propose une autre stratégie plus loin : \ref{sub:event_amel}.

\subsection{Introspection}

L'implémentation actuelle de cette stratégie de traitement pose un problème pour typer l'emetteur.
Pour pallier à celà, j'ai fourni lors de la construction des objets un champ supplémentaire
\footnote{Le champ kind étant effacé à l'instanciation Enyo, il n'est pas possible d'en faire usage} à chaque
``kind'' qui va s'étendre à l'objet Javascript : \emph{\_onyo\_id}.

Munis de cette propriété, nous pouvons désormais accéder à ce champ pour le typer correctement.
C'est le rôle de la fonction \emph{as\_a}:

\begin{OCaml}
  val as_a : ([< any_id] as 'a) -> [< any_id] obj -> 'a obj
\end{OCaml}

Si l'objet n'est pas de l'``id'' spécifié, une exception est levée.

Avec ceci, nous pouvons agir sur l'emetteur :
\begin{OCaml}
  let mon_bouton = ~content:"Bouton" ~tap:(fun _ _ _ -> false) ()

  let traitement this emetteur evenement =
     try 
         let bouton_emetteur = as_a `BUTTON emetteur in
         (* bouton_emetteur : [`BUTTON] obj *)
         setDisabled bouton_emetteur true;
         true
     with Bad_kind -> true

  let mon_control = ~components:[mon_bouton] ~ontap:traitement ()
\end{OCaml}

Dans cet exemple, le bouton capture l'événement \emph{ontap} mais le délégue
à son composant racine. Ce dernier essaye de transtyper l'émetteur en bouton
et le désactive.

Cette solution reste cependant inélégante et assez contraignante pour le développeur.

\subsection{Autre stratégie de propagation}\label{sub:event_amel}

Dans un développement Enyo, il est courant de ne définir les fonctions de traitement qu'à la racine de l'arbre
de composants. Ceci permet d'avoir un accès à tous les sous-composants grâce à la table de hash que possède
le composant principal. Nous obtenons ainsi le programme reprenant l'exemple posant problème :
\begin{JavaScript}
  enyo.kind({
    kind:"Control",
    name:"App",
    components:[
      {
        kind:"Control",
        components:[
          {kind:"Button", name:"b1", content:"Vert",
            ontap:"tap"
          },
          {kind:"Button", name:"b2", content:"Bleu",         
            ontap:"tap"
          }
        ]
      }
    ],
    tap:function(emetteur, event){
      if (this.$.b1 == emetteur){
        // couleur noire
      } else if (this.$.b2 == emetteur){
        // couleur blanche 
      }
      return true;
    }
    //Il peut aussi etre interessant de definir une fonction pour chaque bouton :
    tap_b1:function(em, ev){ 
      //couleur noire
      return true;
    }
    tap_b2:function(em,ev){
      //couleur blanche
      return true;
    }
})
\end{JavaScript}

Un comportement semblable pourrait être implémenté résolvant par la même occasion, le typage de l'émetteur.

Plutôt que de définir les fonctions de traitement au niveau des objets, on pourrait les définir
sous des labels uniques, à la racine. Nous obtiendrions, une signature dans le constructeur
pour le traitement de ce type ressemblant à :
\begin{OCaml}
  button ?content:string
         (* ... *)
         ?ontap:([`APPLICATION] obj -> 
                 [`BUTTON] obj -> 
                 [`GESTURE] obj -> bool)
\end{OCaml}

Il conviendrait à priori de définir un nouvel objet ``Application'' sur lequel il serait possible de
fournir une lecture de la table de hash et ainsi d'agir sur les différents objets.

L'instanciation à même titre retournerait un : \emph{[`APPLICATION] obj}.

J'essayerai de convenir de la validité d'une telle approche et de son implémentation dans une 
version future.
