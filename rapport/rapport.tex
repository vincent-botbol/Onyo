\documentclass[11pt,a4paper]{report}

\evensidemargin=0cm
\oddsidemargin=0cm
\topmargin=-1cm
\textheight=23.5cm
\leftmargin=0cm
\textwidth=18cm
\sloppy
\flushbottom
\parindent 1em
\hoffset -0.5in
\oddsidemargin  0pt
\evensidemargin 0pt
\marginparsep 10pt

\usepackage[utf8]{inputenc}
\usepackage[frenchb]{babel}
\usepackage[T1]{fontenc}

\usepackage[hidelinks]{hyperref}
\usepackage{tikz}
\usetikzlibrary{arrows,positioning,trees} 
\tikzset{
    %Define standard arrow tip
    >=stealth',
    %Define style for boxes
    punkt/.style={
           rectangle,
           rounded corners,
           draw=black, very thick,
           text width=6.5em,
           minimum height=2em,
           text centered
    },
    punkt2/.style={
      rectangle,
      draw=black, very thick,
      text width=6.5em,
      minimum height=2em,
      text centered
    },
    % Define arrow style
    pil/.style={
           ->,
           thick,
           shorten <=2pt,
           shorten >=2pt,}
}

\usepackage{listings}
\usepackage{color}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}
\lstnewenvironment{JavaScript}
                  {\lstset{%
                      language=JavaScript,
                      %backgroundcolor=\color{lightgray},
                      extendedchars=true,
                      basicstyle=\footnotesize\ttfamily,
                      showstringspaces=false,
                      showspaces=false,
                      numbers=left,
                      numberstyle=\footnotesize,
                      numbersep=9pt,
                      tabsize=2,
                      breaklines=true,
                      showtabs=false,
                      captionpos=b%
                    }
                  }
                  {}

\lstnewenvironment{OCaml}
                  {\lstset{
                      language=[Objective]Caml,
                      breaklines=true,
                      commentstyle=\color{purple},
                      stringstyle=\color{red},
                      identifierstyle=\ttfamily,
                      keywordstyle=\color{blue},
                      basicstyle=\footnotesize
                    }  
                  }
                  {}

\title{Rapport de stage\\Programmation Enyo en OCaml}
\author{Vincent Botbol}
\date\today

\begin{document}
\maketitle

\chapter{Introduction}

En quelques années, les appareils mobiles se sont peu à peu imposés sur le marché technologique.
Grâce à leurs interfaces graphiques simplifiées et leurs fonctionnalités, ces outils ont sû se 
rendre indispensable auprès du grand-public.
Aujourd'hui, environ un tiers de la population possède un smartphone ou une tablette.

La variété de ces appareils est telle que la tâche est parfois agaçante pour les développpeurs 
d'exporter leurs applications sur d'autres systèmes utilisant des langages différents.
La nécessité d'une unification s'est donc imposée. Pour se faire, le choix des constructeurs quant à
la technique s'est dirigé vers les nouvelles technologies web :
HTML5 et JavaScript. Populaire et en constante évolution, ces deux solutions apportent un grand nombre
de possibilités.

Le but de ce stage est de permettre au programmeur de développer des applications portables de manière sûre
en passant pour cela par le langage OCaml garant d'une solidité à travers la puissance de son typage statique
tout en gardant le confort de programmation qu'on lui connait.
Pour se faire, on s'est intéressé à la bibliothèque JavaScript ``Enyo'' qui facilite la construction d'interface
graphique des applications (voir \ref{chap:enyo}).

La traduction d'OCaml vers JavaScript a déjà été mise-en-\oe{}uvre dans plusieurs travaux : OBrowser
et Js\_of\_ocaml. Fournissant des bases intéressantes pour ce projet, il a été pratique d'en faire usage
pour s'abstraire du problème d'inter-opérabilité entre les deux langages.

La divergence entre JavaScript et OCaml est grande. Cela peut beaucoup jouer lors d'un tel 
interfaçage. Il est alors important de bien étudier la bibliothèque afin de déterminer le niveau
d'utilisation des traits intrusifs.
En répondant cette question, il faut pouvoir déterminer le type de modèle et sa représentation
s'adaptant le mieux.
Les objets Enyo étant nombreux, il faut se donner un moyen de les représenter 
de façon efficace. Se munir d'un IDL peut-il être un atout pour réaliser ceci?

Premièrement, nous étudierons Enyo pour nous permettre d'obtenir les informations nécessaires 
pour établir une approche.

Ensuite, nous tenterons de fournir un modèle en détaillant les raisons de ce choix et les problèmes
qui en ressortent.

Enfin, nous présenterons un IDL permettant de modéliser les objets Enyo.

Quelques exemples d'applications Enyo implémentés en OCaml utilisant le module d'interfaçage
seront également présentés.

%%%%%%%%%%%%%%%%%%
%   CHAPITRE 1   %
%%%%%%%%%%%%%%%%%%
\chapter{Présentation Enyo}\label{chap:enyo}
\section{Introduction}
Enyo\cite{enyo} est un framework Javascript orienté-objet. Il privilégie un style de développement basé
sur une encapsulation arborescente de composants.\medskip

Dans sa première version, Enyo fut employé pour le développement d'application pour 
tablettes et téléphones fonctionnant sous webOS. Après un succès mitigé,
HP décida de transformer webOS en projet \emph{open source} devenant ainsi : Open WebOS.\medskip

Enyo passe alors en version 2.0. Sa conception en Javascript profite de  
l'engouement actuel pour ce langage et permet aux développeurs de déployer leurs 
applications sur les plateformes le supportant, ce qui aujourd'hui désigne 
la plupart des appareils grand public (Android, iOS, WindowsPhone, etc.)\medskip

On peut attribuer à Enyo des avantages tels que sa prise en main aisée grâce au style 
de programmation proche d'une vision du DOM\footnote{Document Object Model}, le poids relativement 
faible de sa bibliothèque et sa possibilité d'extension relativement aisée.

\clearpage

\section{Débuter en Enyo}

Il est important de distinguer trois phases dans le développement d'une application 
Enyo.
\begin{itemize}
\item La première, dite de déclaration, consiste à définir les composants, leurs positions dans 
la hiérarchie de l'application ainsi que la logique de l'application.
\item La seconde est celle de la génération. Permettant à la bibliothèque Enyo de 
  fournir les méthodes et propriétés manquantes à l'objet décrit par la phase 
  de déclaration, l'objet destiné à être instancié.
\item Enfin, nous avons la phase d'instanciation où le résultat de la génération
est à même d'être créé puis utilisable, par exemple, en l'affichant.
\end{itemize}\medskip

On observe ainsi de fortes similitudes avec un langage de description d'interface.
Il faut commencer par \emph{décrire} l'objet, ensuite le \emph{générer} 
pour enfin l'\emph{utiliser}.

La définition des composants de l'application consiste à déclarer 
des objets Javascript possédant des propriétés qui auront un sens au moment d'étendre
l'application.\smallskip

Par exemple, définissons un simple morceau de texte contenant la chaine ``Bonjour monde!'':
\begin{JavaScript}
  var monApplication = {kind: "Control",
                        name: "MonApp",
                        content: "Bonjour monde!"}
\end{JavaScript}

Ici, nous avons simplement déclaré un objet Javascript\footnote{%
Pour simplifier les déclarations d'objets, nous utilisons la 
notation Json de JavaScript.}
muni de propriétés suffisantes pour renseigner Enyo sur le type d'objet à créer.\\
Explicitons ces propriétés :
\begin{itemize}
\item \emph{kind} définit le type d'objet Enyo que nous souhaitons créer.\smallskip
\item \emph{name} nomme l'objet que nous sommes en train de créer. C'est par la
valeur de cette propriété que nous pourrons accéder à un composant ou encore l'instancier.
\footnote{Il est important de noter que si placée dans un composant en racine de l'application,
la propriété \emph{name} déterminera le nom de la classe générée. Autrement, le nom d'un sous-composant
servira de clé à une table d'association définie sur le composant racine de l'application 
servant à récupérer les divers sous-composants
}\smallskip
\item \emph{content} attribut un texte au composant. Cette propriété concerne les objets Enyo de type 
``Control'' ou un de ses descendants héritant de celle-ci.\smallskip
\end{itemize}\medskip

Désormais défini, il faut passer le composant à la méthode \emph{kind} d'Enyo pour générer la nouvelle
classe de l'application.

\begin{JavaScript}
  enyo.kind(monApplication);
\end{JavaScript}

A la suite de cet appel, on pourra constater qu'une nouvelle classe \mbox{\emph{MonApp}} 
a été ajouté à l'environnement global de JavaScript. Il ne reste donc plus qu'à l'instancier 
pour pouvoir ensuite l'afficher.

\begin{JavaScript}
  var app = new MonApp();
  app.renderInto(document.body);
\end{JavaScript}

En s'intéressant de plus près à l'objet ``app'', on peut constater qu'il
possède un nombre important de méthodes et de propriétés que nous n'avons 
pas définies à la description, telle que la méthode \emph{renderInto}
que nous venons d'utiliser.

Ces méthodes ont été ajoutées par induction lors de la génération de 
l'application par la méthode \emph{enyo.kind}.

Si le champ \emph{kind} spécifie un ``Control'', il est donc nécessaire à Enyo de
lui rajouter toutes les propriétés et méthodes que possède un Control Enyo qui
n'ont pas été définies par l'utilisateur.

\section{Ajout de sous-composants}
Enyo suivant une logique d'arborescence de composants. Lorsque l'on crée 
son application, il est nécessaire de pouvoir lui ajouter des sous-composants. 
On réalise cela en définissant la propriété \emph{components} avec en valeur le tableau 
des composants que nous souhaitons.

Imaginons ici que l'on souhaite créer une application consistant d'un champ de saisie 
et d'un bouton de validation:
\begin{JavaScript}
 enyo.kind({kind:"Control",
            name:"MonApp",
            components: [
                         {kind:"Input"},
                         {kind:"Button", content:"ok"}
                        ]
           });
\end{JavaScript}

La fonction kind va récursivement créer tous les sous-composants de la hiérarchie 
ainsi que leur méthodes associées.

Comme précédemment, pour l'afficher, on instancie la nouvelle classe générée 
et on lui applique une méthode d'affichage : 

\begin{JavaScript}
  var app = new MonApp();
  app.renderInto(document.body);
\end{JavaScript}

Si l'on observe le code html après ces appels, on s'aperçoit qu'enyo a injecté dans 
le DOM une balise html de type <div> dans laquelle sera placée, respectivement, 
deux balises : un <input type="text" ..> et un <button>.

Notons que nous n'avons pas défini la propriété \emph{name} des sous-composants. 
Rappelons que le nom d'un composant sert uniquement à l'accession de celui-ci par les 
autres composants de la hiérarchie ou encore pour son instanciation. Cependant, lors de
l'appel à \emph{enyo.kind}, seule la racine de l'arbre sera étendu à l'environnement global
d'exécution JavaScript.

Il faut aussi noter que si la propriété name n'est pas définie, Enyo s'en charge en lui donnant 
un label géneré (``input0'' et ``button0'' ici). Il n'est évidemment pas recommandé 
d'utiliser ces derniers pour y accéder.

\section{\'Evénements}\label{sec:event}

Reprenons l'exemple précédent et supposons désormais que l'on souhaite, lorsque l'on clique sur le bouton, afficher un message d'alerte.

\begin{JavaScript}
enyo.kind({kind:"Control",
           name:"MonCadre",
           components: [
             {kind:"Input", value:""},
             {kind:"Button", content:"ok",
              handlers:{ontap:"monCallback"},
              monCallback:function(sender, event){
                alert("ok");
                return true;
              }
             }
           ]
       	  });
\end{JavaScript}

Au bouton, nous avons rajouté une propriété \emph{handlers}. 
Cet objet sert à définir tous les événements que l'objet va traiter. 
Cela peut-être des événements du DOM (onkeyup, onload, ...) comme des événements 
spécifiques à la plateforme sur laquelle l'application est déployée 
(l'inclinaison d'une tablette par exemple). Ici, nous utilisons l'événement "ontap", alias d'"onclick".\\

A chaque propriété-événement est attachée une chaine contenant le nom de la fonction à appeler.

Nous définissons donc la fonction ``click'' qui prend en premier argument l'émetteur de 
l'événement et l'événement envoyé contenant ses propriétés.

La valeur de retour de cette fonction spécifie si l'événement doit s'arrêter ou 
remonter (``bubble'') aux composants parents. On retourne vrai pour l'empêcher de 
remonter et faux pour le laisser ``buller'' sur ses ancêtres.

On notera qu'en général, les fonctions de traitement ne pas censées devoir remonter l'arbre
sont définies à la racine qui possède un accès à tous ses sous-composants 
grâce à sa table de hash ``\$''.

Il existe quelques spécificités pour la manipulation d'événements :
\begin{itemize}
\item Si la fonction de traitement n'est pas trouvée, l'événement est remonté dans l'arbre de 
  composants jusqu'à la trouver au niveau de ses parents.
\item Il n'est nécessaire de déclarer le bloc \emph{handlers} que lorsque la fonction de traitement
  se situe au même niveau de déclaration que l'événement. Par exemple, cette définition est parfaitement valable :
  \begin{JavaScript}
    enyo.kind({kind:"Control", 
               components:[{kind:"Bouton", 
                            ontap:"traiteClique"}
                          ],
               traiteClique:function(sender, event){
                 alert("Click recu"); return true
               }
    });
  \end{JavaScript}
\item Il est possible de propager un événement manuellement en utilisant la fonction 
  \emph{send(nomEvenement, evenement)} de l'objet \emph{enyo.Signals}. 
  Cet événement est remis à tous les objets de type \emph{kind:"Signals"}. Il suffit alors
  à l'objet-récepteur de posséder un sous-composant de ce type et d'implémenter la fonction de 
  traitement lié au handler du sous-composant. (voir exemple)
\end{itemize}
%XXXXXXXXXXXXXXXXX
%insérer des exemples de prog
%XXXXXXXXXXXXXXXXX

\section{Propriétés published}\label{sec:published}
Les propriétés placées dans l'objet interne ``published'' du composant sont en général utilisées pour
la logique de l'application. Certains "published" sont déjà présents dans les objets Enyo. 
Par exemple, la propriété "content" de l'objet "Control" est elle-même publiée.

Enyo traite ces propriétés comme étant des variables publiques et génère automatiquement : 
getter, setter ainsi qu'une méthode valueChanged appelée à chaque appel du set avec une nouvelle valeur.
\\\medskip

En résumé, un composant déclaré ainsi : 
\begin{JavaScript}
  {kind:"app", published:{maVariable:0}}
\end{JavaScript}
est équivalent à :
\begin{JavaScript}
  {kind:"app", maVariable:0, 
    getMaVariable:function(){..}, 
    setMaVariable:function(nouvelleValeur){..}, 
    maVariableChanged:function(ancienneValeur){}}
\end{JavaScript}

%XXXXXXXXXXXXXXXXX
%insérer des exemples
%XXXXXXXXXXXXXXXXX

Cependant il reste possible d'initialiser les valeurs de propriétés 
déjà publiées hors de l'objet \emph{published} de la même façon dont nous procédions 
avec le champ \emph{content} jusqu'à présent. Cela aura uniquement pour effet de  masquer la première 
initialisation que le constructeur Enyo aura effectué.

Note : la propriété \emph{monObjet.published.maVariable} sert seulement à indiquer à Enyo 
qu'il doit générer la variable et sa barrière d'abstraction.
Il ne faut donc pas confondre celle-ci avec \emph{monObjet.maVariable} qui contiendra
la valeur manipulée par les ``getters et setters''.

\section{Copie, partage et réutilisation de composants}

Il est possible de réutiliser des composants déjà créés. Il faut cependant faire attention à ne pas
lui attribuer de nom. Dans le cas échéant, le constructeur considèrera que l'objet existe déjà et 
tous les traitements visant une des occurrences de ce nom seront appliqués au premier objet défini.

\begin{JavaScript}
var unBouton = {kind:"Button", name:"bouton1", 
                handlers:{ontap:"clique"}, 
                content:"un bouton",
                clique:function(){
                  this.setContent("Reception du click")
                }
};

enyo.kind({name:"App", components:[unBouton,unBouton]});
\end{JavaScript}

Dans cet exemple, au moment de l'instanciation un message d'avertissement concernant une collision de nom 
est émis mais les deux boutons s'afficheront correctement. Cependant, on constate bien que les clicks 
émis sur l'un ou l'autre des boutons n'auront pour effet de changer que le premier des deux boutons.\\\medskip

Typiquement, si l'on souhaite réutiliser un composant déjà implémenté,
il est recommandé de procéder comme dans l'exemple suivant.

Ici, on commence par décrire un nouvel objet bouton avec son fonctionnement
personnalisé puis en l'étendant avec la fonction \emph{enyo.kind}, il est possible de
le réutiliser dans une nouvelle description de composant.

\begin{JavaScript}
enyo.kind({kind:"Button", name:"MonBouton", 
           handlers:{ontap:"clique"}, 
           content:"un bouton",
           clique:function(){
             this.setContent("Reception du click")
           }
});

enyo.kind({name:"App", 
           components:[
             // Creation de deux MonBouton
             {kind:"MonBouton", name:"bouton1"},
             {kind:"MonBouton", name:"bouton2"}]
});
\end{JavaScript}

\section{Hiérarchie des objets}

On peut considérer la plupart objets Enyo dans la hiérarchie comme des n\oe{}uds HTML,
en effet, lorsque l'on construit son application, la forme arborescente de l'arbre se traduit
particulièrement bien sous une forme HTML. Ainsi, un \emph{Button} Enyo est lui-même transformé
en un n\oe{}ud ``<button>'' à l'instanciation. Il est donc aisé de se représenter le rendu final 
d'une application.

Voici un aperçu de l'arbre des composants d'Enyo :\medskip

\begin{center}
\begin{tikzpicture}
  [grow=right, level 1/.style={sibling distance=3em},
    level 2/.style={sibling distance=3em}, level distance=2.5cm]

\node (object) {Object}
  child {node (compo) {Component}
    child {node (uicompo) {UIComponent}
      child {node (control) {Control}
        child {node (etc) {...}}
        child {node (input) {Input}
          child {node (textarea) {TextArea}}
          child {node (checkbox) {Checkbox}}
        }
        child {node (Popup) {Popup}}
        child {node (option) {Option}}
        child {node (image) {Image}}
      }
    }
    child {node (animator) {Animator}}
  }
  child {node (async) {Async}
    child {node (ajax) {Ajax}
    }
  };
\end{tikzpicture}
\end{center}

L'arbre complet peut-être trouvé en annexe (\ref{hier-complet}).

La plupart des objets héritent de la classe \emph{Control}. En effet, c'est à partir de celle-ci
que l'on obtient des fonctions d'affichage et la génération d'un n\oe{}ud html.
Les objets parents de \emph{Control}, tel que \emph{Component} ou \emph{Object} ne servent, en pratique,
qu'à établir une logique dans le code (création de temporisateurs, calculs de valeurs, etc.).
On peut donc tout à fait se passer de ceux-ci lors de l'utilisation en OCaml\footnote{La logique de
l'application étant gérée par le programme OCaml}.

\section{Bibliothèques additionnelles}

Enyo possède un ensemble de bibliothèques supplémentaire apportant du contenu à l'API de base.
On peut par exemple utiliser la bibliothèque Onyx pour fournir une interface graphique 
supérieure ou encore Layout pour organiser ses composants de la manière souhaitée.

Ces objets viennent généralement se greffer à la hiérarchie existante. Par exemple,
``Onyx.Input'' hérite de ``Control''.

Pour pouvoir utiliser cette extension, il est nécessaire de l'indiquer à l'application.
Il faut faire appel à \emph{enyo.depends} sur la liste des bibliothèques à lier.
Par exemple, si l'on souhaite utiliser des objets d'``Onyx'' et de ``Layout'', il faut procéder ainsi :

\begin{JavaScript}
  enyo.depends{ "$lib/Onyx", "$lib/Layout"}
\end{JavaScript}

Il est bien sûr requis de fournir le dossier contenant ces extensions au même niveau que le dossier
``enyo''. Voici une arborescence classique d'une application Enyo :

\begin{center}
\begin{tikzpicture}
  [level 1/.style={sibling distance=3cm},
    level 2/.style={sibling distance=1.5cm}]
  \node {application}
    child { node {enyo}
      child{ node {enyo.js}}
    }		
    child { node {lib}
      child{node {Onyx}}
      child{node {Layout}}
      child{node {...}}
    }
    child { node {index.html}}
    child { node {dependances.js}}
    child { node {source}
      child { node {App.js}}
      child { node {App.css}}
    };
\end{tikzpicture}
\end{center}

\subsection{Onyx}

La bibliothèque Onyx enrichit l'application en apportant un ensemble de style prédéfinis pour 
des objets de bases. L'objectif étant d'obtenir une interface graphique correcte sans avoir
à passer du temps sur le style de l'application.

\subsection{Canvas}

Cette extension gère la partie canvas d'HTML5 d'Enyo. Elle définit des objets pour simplifier 
le code JavaScript et ainsi s'abstraire légèrement de la couche basse d'HTML5. Il est ainsi
possible de dessiner des formes simples dans le canvas.

Cependant, cette bibliothèque a ses limites et l'intérêt décroit à mesure que l'application se complexifie.
Il est parfois inévitable de recourir aux fonctions de bases de manipulation de canvas pour obtenir
le résultat escompté.

\subsection{Layout}

La bibliothèque ``Layout'' permet d'établir une discipline de placement dans l'application.
On peut grâce à cela, organiser le rendu visuel de l'application avec plus de flexibilité
que ne permet l'API de base. Par exemple, lister des éléments verticalement plutôt qu'horizontalement.

%%%%%%%%%%%%%%%%%%
%   CHAPITRE 3   %
%%%%%%%%%%%%%%%%%%
\chapter{Interfaçage d'Enyo en OCaml : Nouveau plan}\label{chap:model}

\section{Interopérabilité entre JavaScript et OCaml}

Pour une adaptation en OCaml d'Enyo, il est nécessaire d'établir une communication
entre les deux langages. Cela présente une première difficulté étant donné le peu
de points communs existants. Deux projets ont été développés sur le sujet : Le premier 
``OBrowser''\cite{pwt}, implémente une machine virtuelle interprétant le bytecode OCaml
en JavaScript à l'exécution. Le second ``Js\_of\_ocaml'', compile le bytecode pour générer
un fichier Javascript qui pourra être ajouté dans une page web. Ces deux solutions
permettent l'exécution d'un programme OCaml (bytecode) dans un navigateur en passant par JavaScript. 

Le problème principal des deux projets réside dans la représentation des valeurs
d'un monde à l'autre. Pour chacun des cas, il a fallu trouver un moyen efficace de
pouvoir transmettre et interpréter des valeurs tout en assurant le typage.
Cela est réalisé par l'analyse du bytecode qui en redéfinissant les blocs OCaml
en valeur JavaScript permettent leur utilisation dans ce monde-ci et inversement pour
les valeurs JavaScript traduies en blocs. Fournissant une sur-couche d'API JavaScript,
le programmeur OCaml est ainsi à même d'utiliser des fonctions JavaScript au sein de son
programme en pouvant s'assurer du typage. L'utilisation de fonctions OCaml en JavaScript
est également possible.

Le problème de l'interopérabilité avec Enyo suit les mêmes contraintes :
Le dynamisme de JavaScript empêche une traduction directe. Il est donc intéressant
d'utiliser l'un de ces outils afin de nous fournir une couche haute pour l'implémentation de
ces valeurs.


\section{Js\_of\_ocaml : Présentation des outils}

Le choix s'est porté sur Js\_of\_ocaml. Celui-ci fournit une représentation assez complète des
objets JavaScript et une manipulation aisée des champs. Une telle liberté peut cependant être source
d'erreurs, venant en particulier du fait que nous utilisons certaines fonctions non-typés.
L'intérêt se limite ainsi à l'interopérabilité et nous nous assurerons du typage lors de la définition
du modèle.

Nous utiliserons en particulier le module Js.Unsafe qui contient des fonctions assez bas niveau
de l'API ``Js\_of\_ocaml'' pour nous permettre les libertés dont on a besoin pour créer nos objets.
Nous nous intéresserons en particulier aux fonctions suivantes :

\begin{OCaml}
(*Type haut permettant de contenir l'ensemble des valeurs JavaScript possibles*)
type any

(*Fonction d'accession aux variables JavaScript
  => variable "monobj", renvoie l'objet "monobj" defini dans l'environnement JavaScript*)
val variable : string -> 'a

(* Coercition d'une valeur vers le type generique de js_of_ocaml *)
val inject : 'a -> any

(*Fonctions d'accession et de modification de champ des objets JavaScript*)
val get : 'a -> 'b -> 'c
val set : 'a -> 'b -> 'c -> unit

(*Appel de fonction JavaScript avec un tableau d'argument
  => fun_call (variable "alert") [| inject 42 |]
  = affiche 42*)
val fun_call : 'a -> any array -> 'b

(*Appel d'une methode d'un objet JavaScript
  => let unsafe_str = meth_call unObj "toString" [| |]*)
val meth_call : 'a -> string -> any array -> 'b

(*Creation d'un objet JavaScript*)
val new_obj : 'a -> any array -> 'b
\end{OCaml}

L'usage de ces fonctions n'étant pas sûr, il va être indispensable de ``recouvrir'' ces appels
à l'aide à notre système de type.

Lorsque l'on passe des arguments aux appels de méthodes, il est nécessaire des les transcrire
en valeurs JavaScript et inversements pour récupérer les valeurs retournées.

La traduction de ces valeurs s'opére grâce aux fonctions de traduction étant elles typées.
\begin{OCaml}
  val bool : bool -> bool t
  val to_bool : bool t -> bool
  val string : string -> string t
  val to_string : string t -> string
  val array : 'a array -> 'a js_array t
  val to_array : 'a js_array t -> 'a array
  (*...*)
\end{OCaml}

Les traductions de ces valeurs s'effectuent par copie. La modification d'une chaîne de
caractères dans le monde OCaml n'aura donc pas d'effet sur l'objet \emph{String} instancié.

Il faut aussi s'assurer de la sécurité des appels des fonctions ou méthodes, par exemple,
pour ne pas générer d'erreurs lors de l'ajout de propriétés dans un objet. Si l'on veut ajouter 
un champ de type string dans un objet JavaScript, il faudra faire appel à la fonction 
\emph{string} qui se chargera de l'instanciation d'un objet JavaScript \emph{String}.

\begin{OCaml}
  let unObj = newobj (variable "Object") [||] in

  (* Correct *)
  set unObj "couleur" (string "vert");
  (* Leve une erreur a l'execution *)
  set unObj "couleur" "rouge";

  get unObj "length"
\end{OCaml}

\section{Typage OCaml d'Enyo}
\subsection{Typage des valeurs simples}

Bien que \emph{Js\_of\_ocaml} nous permette d'approcher un typage correct de valeurs, nous ne souhaitons pas
que l'utilisateur ait à connaître ni les spécificités ni les types de celui-ci.
Il faut alors se munir d'un ensemble de valeurs dont on est susceptible de passer à JavaScript
et/ou de les récupérer afin d'assurer la sécurité du typage.

\begin{OCaml}
  type js_value = Int of int | Float of float
                | Bool of bool | String of string
                | Array of js_value list 
                | Component of any_id obj | Dom_node of dom_node
\end{OCaml}

Notes : 
\begin{itemize}
\item J'ai préféré représenter le tableau JavaScript sous forme de liste. Sa manipulation étant 
  plus similaire que celle d'un tableau OCaml
\item Le \emph{Dom\_node} et le \emph{Component} seront repris plus tard 
\end{itemize}

Ce type nous permettra également de savoir quel type de conversion est nécessaire selon 
la valeur passée.
Par exemple, si le champ contient un type \emph{String v}, nous savons qu'il faudra appliquer
la fonction \emph{Js.string} de \emph{js\_of\_ocaml} pour correctement la transcrire.

\subsection{Typage des composants}

Pour typer efficacement les composants, on a envie d'ajouter une information précise sur le type
de la description qui sera répercuté sur l'objet JavaScript au moment de l'instanciation. Pour se faire,
l'utilisation de type fantôme\footnote{Un type fantôme est un type paramétrique dont au moins un paramètre 
n'est pas utilisé dans sa définition.} est intéressante. Ce choix est ici appuyé par la représentation équivalente 
des données décrivant les composants Enyo. Un bon moyen d'établir leur différenciation est donc de fournir
cette information.

\begin{OCaml}
  type +'a kind
  type +'a obj
\end{OCaml}

Notes : 
\begin{itemize}
\item \emph{kind} représente la description de l'objet et \emph{obj} l'objet JavaScript correspondant
  à la génération puis à l'instanciation Enyo. Le sujet est plus amplement abordé dans les sections
  suivantes.
\item Le signe ``plus'' indique l'utilisation covariante du type qui sera nécessaire pour l'usage
  combiné aux variants.
\end{itemize}

Combinés aux variants polymorphes, on peut profiter de leur sous-typage.
Ceci devient utile pour définir des méthodes s'appliquant uniquement à un ensemble défini de de composants
Cette abstraction permet ainsi d'assurer un typage correct.

Pour la librairie, un ensemble d'identifiants a été défini\footnote{Nous n'en prennons que 
trois pour l'exemple} :

\begin{OCaml}
  type any_id = [ `CONTROL | `INPUT | `BUTTON ]
\end{OCaml}

A l'usage, les types abstrait des descriptions de composants (\emph{+'a kind}) seront sous-type d'any\_id.
De plus, une fonction chargée de la traduction des descriptions de composants en objet JavaScript sera définie et 
permettra la transmission de l'information de type :

\begin{OCaml}
  let un_bouton = button ()
  (* val un_bouton : [> `BUTTON] kind *)
  let un_input = input ()
  (* val un_bouton : [> `INPUT] kind *)
  (****************************)
  val traduction : ([< any_id] as 'a) kind -> 'a obj
  (****************************)
  let objet_javascript = traduction un_bouton
  (* val objet_javascript : [< `BUTTON] obj *)
\end{OCaml}

Les méthodes partagées par un ensemble spécifique de composants Enyo pourront ainsi prendre cette forme :
\begin{OCaml}
  (* Ces fonctions accepteront au moins un des types specifies *) 
  val meth1: [< `CONTROL | `INPUT | `BUTTON ] obj -> unit
  val meth2: [< `INPUT | `BUTTON ] obj -> int
\end{OCaml}

Avec un typage simple, ce partage de noms n'aurait pas été possible. Ceci aurait entraîné une
répétition importante du nombre de méthodes possédant une définition pourtant équivalente.

\section{Description en OCaml des déclarations d'Enyo}
\subsection{Modélisation}

Nous avons décrit dans la partie consacrée à la présentation d'Enyo, les trois grandes phases, à savoir :
La description, la génération et l'instanciation.

Le résultat de la description de l'objet permettra à Enyo d'établir la génération de cet objet en lui
fournissant méthodes et initialisation d'attributs. L'instanciation de cet objet permettra l'appel
des méthodes qu'Enyo lui a fourni. Ainsi, il est possible de décrire un objet mais il faudra
le générer puis l'instancier pour être à même de faire des appels de méthodes sur celui-ci.

Nous représentons la description avec le type \emph{kind} et l'objet instancié par le type \emph{obj}.

Nous nous intéresserons ici à la description de l'objet et à son implémentation en OCaml.

Un composant Enyo étant défini par des propriétés, méthodes et sous-composants, il a fallu se munir
d'une structure les regroupant.
\begin{OCaml}
  type +'a kind = {id:string; 
                   components: any_id kind list; 
                   prop_list : (string * js_value) list;
                   handler_list:handler list
                  }
\end{OCaml}

Notes : 
\begin{itemize}
  \item Le champ ID sera utilisé pour l'instrospection (voir \ref{introspec}).
  \item Le type abstrait n'étant pas utilisé dans la définition, le type est donc bien
    fantôme.
\end{itemize}\medskip

Nous avons trois différentes listes :
\begin{itemize}
\item Une liste de descriptions de sous-composants \emph{components} similaire à
  une implémentation en Enyo.
\item Une liste de propriétés prenant un couple composé du nom du champ ainsi 
  que de la valeur associée.
\item La liste des fonctions de traitement d'événements que nous étudierons plus tard.
\end{itemize}

Contrairement à Enyo, la définition de nouvelles méthodes n'est pas intéressante pour le programmeur
qui va plutôt souhaiter définir ses propres fonctions et la logique de l'application en OCaml.
Cependant, il est nécessaire de définir les fonctions de traitements d'événements qui permettront
d'établir la logique de l'interface graphique et de l'appel du modèle de calcul de l'application.

Ainsi défini, l'utilisateur doit choisir les attributs de l'objet (texte du bouton, valeur initiale
d'un champ de saisie, etc.). Le nombre d'arguments peut croitre de manière assez importante et devenir
vite gênant pour l'utilisateur.
C'est pourquoi, en s'inspirant des modules d'interfaces graphique d'OCaml (Tk, lablGtk), il a été intéressant de
procéder par arguments optionnels. L'utilisateur choisi à partir d'un ensemble d'arguments, ceux qu'il 
lui conviennent et génère ainsi la description.

Nous obtenons un type comme celui-ci pour un constructeur d'objet:
\begin{OCaml}
  val input:
            ?components:any_id kind list
            -> ?value:string
            -> ?content:string
            -> ?name:string
            (* ... *)
     	    -> ?ontap:([`INPUT] obj -> any_id obj -> [`GESTURE] obj -> bool)
  	    -> unit -> [>`INPUT] kind
\end{OCaml}

A l'usage, le programmeur pourra obtenir un code clair et concis :
\begin{OCaml}
  let mon_champ = input ~value:"Bonjour" ()
\end{OCaml}

Le corps de la création de description est relativement simple.
On spécifie le type du composant en ajoutant la propriété \emph{kind} et la valeur
correspondante au composant en cours de création.
Il suffit ensuite de tester pour chaque paramètre optionnel son existance et de l'ajouter 
si il est défini. On retourne ensuite la structure munie des listes.
\begin{OCaml}
let input
	?(components=[])
	?value
        ?content
	?name
        (*...*)
	?ontap
	() =
   let prop_list= ref [("kind", String "Input")]
   and handler_list= ref [] in
   (match value with 
       Some v -> 
         prop_list := ("value",String v)::!prop_list 
     | None -> ());
   (match content with 
       Some v -> 
         prop_list := ("content",String v)::!prop_list 
     | None -> ());
  (match name with 
       Some v -> 
         prop_list := ("name",String v)::!prop_list
     | None -> ());
  (*...*)
  (match ontap with 
       Some v -> 
         handler_list := Handler ("ontap",v)::!handler_list 
     | None -> ());
  {id="INPUT"; components=components;
  prop_list=(!prop_list); handler_list=(!handler_list)}
\end{OCaml}

\subsection{Propriétés}

Les propriétés déclarées à la construction de la description sont toutes de type \emph{Published}
comme le veut la spécification Enyo (voir \ref{chap:enyo}). Il faut donc leur fournir
des méthodes d'accessions et de modifications. Je n'ai pas jugé utile de permettre la définition
des méthodes de traitement lors de la modification de valeur (\emph{<valueName>Changed}) : 
il n'est pas utile pour le programmeur d'avoir ce genre de fonctions, si un traitement est à faire
lors du changement d'un champ, le programmeur peut le réaliser au même moment qu'à l'appel du
modificateur.

En ce qui concerne les méthodes \emph{get} et \emph{set}, leur implémentation reste très proche
de celle de \emph{js\_of\_ocaml} à ceci près qu'il faut veiller à traduire les valeurs selon le
sens de communication des langages.
Ainsi, pour les propriétés, leurs barrière d'abstraction différeront uniquement selon le type 
de la propriété. Un exemple de ces méthodes avec celles de la propriété \emph{content} 
de l'objet \emph{Control} :

\begin{OCaml}
  let getContent this () =
	let value = meth_call this "getContent" [||] in
		to_string value
  let setContent this chaine1 =
	let _ = meth_call this "setContent" [|inject (string chaine1)|] in
		()
\end{OCaml}

\subsection{\'Evénements}

Les événements ont la particularité d'être définis au niveau de la description mais agiront sur les objets
instanciés à l'exécution. Dans Enyo, la spécification des événements et de leur fonctions 
de traitement gardent toujours la même forme.

\begin{JavaScript}
  fonctionTraitement: function(emetteur, evenement){
                          //traitement
                          return bool; }
\end{JavaScript}

La fonction attachée prend en paramètres l'émetteur de cet événement, c'est-à-dire, 
le composant qui a généré ou propagé celui-ci, et l'objet événement lui-même.
Celui-ci retourne un booléen spécifiant si la propagation doit être effectuée.
(voir : \ref{sec:event} pour plus de détails)

Pour adapter l'événement en OCaml, j'ai choisi ce type :
\begin{OCaml}
  type any_event = [`GESTURE (* |  Ensemble des evenements *) ]
  type handler = Handler of string * (any_id obj -> any_id obj -> any_event obj -> bool)
\end{OCaml}

Note : nous utilisons également un type fantôme pour les événements.

La gestion de l'événement est donc représentée par un couple contenant le nom de l'événement et la 
fonction de traitement associée avec en premier argument le \emph{this} de la méthode.

Nous utilisons pour réaliser cela, la fonction \emph{wrap\_meth\_callback} de \emph{Js\_of\_ocaml} :
\begin{OCaml}
type (-'a, +'b) meth_callback
(* Fonction prenant en premier argument l'objet representant le "this"
   et en arguments suivants les differents parametres que la
   fonction doit prendre et le type du resultat *)
val wrap_meth_callback : ('a -> 'b -> 'c) -> ('a, 'b -> 'c) meth_callback
\end{OCaml}
%à approfondir 

Cette fonction "attache" à l'objet une méthode qui va se charger d'appeller la fonction OCaml
en transmettant d'un monde à l'autre les arguments nécessaires.

La signature du constructeur de l'objet permet alors de constituer un typage correct.
Nous pouvons ainsi résoudre le \emph{this} selon l'objet en cours de construction et l'événement attendu.
L'émetteur ne peut cependant pas être résolu, nous y reviendrons plus loin.

Pour un champ de saisie, nous attendrons un argument de ce type :

\begin{OCaml}
  val input:
    (*...*)
    -> ?ontap:([`BUTTON] obj -> any_id obj -> [`GESTURE] obj -> bool)
    -> unit -> [>`BUTTON] kind
\end{OCaml}

A l'utilisation, nous pourrons utiliser les méthodes de ``button'' sans causer de conflit de type 
puisqu'employé dans un contexte correct :

\begin{OCaml}
let traitement_bouton this emetteur evenement = 
   setContent this "Nouveau contenu"; 
   setDisabled this true; 
   true
(*
val traitement_bouton :
  [< `BUTTON | `CHECKBOX | `INPUT ] obj -> 'a -> 'b -> bool
*)

let mon_bouton = button ~content:"contenu" ~ontap:traitement_bouton ()
\end{OCaml}

Ici, l'utilisation des méthodes \emph{setContent} puis \emph{setDisabled} infère le
type \emph{[< `BUTTON | `CHECKBOX | `INPUT ]} à la fonction de traitement qui est
acceptable selon le type attendu par \emph{ontap}.

La définition des événements s'effectue de la même manière que celle des objets. Il n'est, en
revanche, pas nécessaire de partager les méthodes appliquables sur les  événements puisqu'ils ne sont pas 
liés entre eux. Il est cependant nécessaire d'affecter à chaque type d'événements des fonctions d'accesseurs pour 
récupérer les informations contenues.

Par exemple, pour l'événement souris, rebaptisé ``gesture'' pour se conformer à Enyo, les accesseurs,
stipulés dans la définition IDL W3C, sont définis comme suit :

\begin{OCaml}
  val gesture_screenX : [`GESTURE] obj-> int
  val gesture_screenY : [`GESTURE] obj-> int
  val gesture_identifier : [`GESTURE] obj-> int
  val gesture_detail : [`GESTURE] obj-> int
  (* ... *)
\end{OCaml}
\medskip

\'A l'instanciation d'un objet pourvu d'un événement, il est nécessaire de passer l'événement traité
dans un objet contenu dans le champ \emph{handlers} de celui-ci. Ainsi, le \emph{mon\_bouton} définit plus haut,
aura cette forme en Javascript :

\begin{JavaScript}
  {kind:"Button", handlers:{ontap:"tap"}, 
    tap:function(){ return callback_caml(this) /* gere par js_of_ocaml */ }}
\end{JavaScript}

\section{Génération et Instanciation}
\subsection{Procédure}

La section précédente nous a permis d'obtenir une description des composants de l'application
grâce à leurs constructeurs retournant les modélisation OCaml de ces objets JavaScript.

\begin{OCaml}
let app = let mon_bouton = bouton ~content:"Valider" in
    control ~components:[mon_bouton] ()
\end{OCaml}

Il faut désormais pouvoir générer puis instancier l'application correspondante. Pour rappel, la génération
correspond à l'appel de la fonction \emph{enyo.kind} sur un objet pour l'étendre à l'environnement,
tandis que la dernière phase instancie cet objet.

\begin{JavaScript}
  //description
  var description = {kind:"Control", name:"App", content:"Bonjour"};
  //generation
  enyo.kind(description);
  //instanciation
  var app = new App()
\end{JavaScript}

La première étape sera de transformer la description représenté en OCaml en objet JavaScript.

Pour procéder, il va falloir créer un objet JavaScript vide et y ajouter propriétés et fonctions
de traitement définies. Voici une version simplifié de la fonction effectuant ce traitement.

\begin{OCaml}
  let rec obj_of_kind kind = 
      let js_obj = new_obj (variable "Object") [||] in
          ajouteProprietes js_obj kind;
          ajouteEvenements js_obj kind;
          set "components" array (Array.of_list (List.map obj_of_kind js_obj kind));
          js_obj
\end{OCaml}

Les fonctions d'ajout se contentent de faire des appels à 
\emph{Js.Unsafe.set} sur l'objet JavaScript \emph{js\_obj} en s'assurant de convertir
correctement les valeurs selon les types. Pour les événements, il est nécessaire
d'utiliser \emph{wrap\_meth\_callback} pour lier la fonction OCaml à l'objet JavaScript.
Enfin, on effectue une récursion sur tous les composants fils.

On obtient ainsi, une description d'objet Enyo conforme et prête à être générer.
On procède avec un appel à \emph{enyo.kind} :

\begin{OCaml}
  let jsobj = obj_of_kind monkind
  
  let _ = fun_call (variable "enyo.kind") [| inject js_obj |]
\end{OCaml}

Désormais, l'environnement possède un objet de nom ``App'' instanciable.

Note : Le nom de l'application est généré si il n'est pas fourni. On supposera qu'``App'' est
le nom donné lors de la description.

Enfin, on l'instancie :
\begin{OCaml}
  let application = new_obj (variable "App") [||]
\end{OCaml}

L'appel à \emph{enyo.kind} et l'instanciation du nouvel objet étant assez concis,
les trois étapes sont effectuées dans la même fonction de type : 
\begin{OCaml}
  val instanciate : ([< any_id] as 'a) kind -> 'a obj
\end{OCaml}

Cette fonction prend donc une description d'un sous-type d'``any\_id'' et retourne 
l'instanciation d'un objet de ce même sous-type. Etant instancié, on peut appeler les méthodes
définies par Enyo pour ce type d'objet.

%ajouter la fonction en annexe

A partir d'un objet instancié, les méthodes dont il hérite ou qu'il implémente, définies dans l'API d'Enyo,
sont désormais appelables. La fonction d'affichage de l'application peut désormais être appelée si
l'objet racine l'implémente.

\begin{OCaml}
  let _ = renderIntoBody app
\end{OCaml}

\subsection{Introspection des objets}\label{introspec}

La stratégie actuelle de traitement des événements pose un problème pour typer l'émetteur.
Pour pallier à celà, on a fourni lors de la construction des objets un champ supplémentaire
\footnote{Le champ kind étant effacé à l'instanciation Enyo, il n'est pas possible d'en faire usage} 
\emph{\_hidden\_id} qui va permettre de distinguer le type de l'objet.

Munis de cette propriété, nous sommes capable de typer le composant.
C'est le rôle de la fonction \emph{as\_a}:

\begin{OCaml}
  val as_a : ([< any_id] as 'a) -> [< any_id] obj -> 'a obj
\end{OCaml}

Cette fonction prend un sous-type d'``any\_id'' ainsi qu'un objet instancié non-typé et retourne 
celui-ci typé. Si l'objet n'est pas de l'``id'' spécifié, une exception est levée.

Avec ceci, nous pouvons typer l'émetteur :
\begin{OCaml}
  let mon_bouton = ~content:"Bouton" ~tap:(fun _ _ _ -> false) ()

  let traitement this emetteur evenement =
     try 
         let bouton_emetteur = as_a `BUTTON emetteur in
         (* bouton_emetteur : [`BUTTON] obj *)
         setDisabled bouton_emetteur true;
         true
     with Bad_kind -> true

  let mon_control = ~components:[mon_bouton] ~ontap:traitement ()
\end{OCaml}

%%%%%%%%%%%%%%%%%%
%   CHAPITRE 4   %
%%%%%%%%%%%%%%%%%%

\chapter{Langage de Description d'Interface (IDL)}\label{chap:idl}

Enyo fournit une API suffisamment grande (une centaine d'objet environ) pour qu'il devienne 
rébarbatif d'implémenter ceci à la main. L'implémentation d'un IDL s'est donc révélé être 
une bonne option pour pouvoir représenter facilement la hiéarchie de classe.

OCaml étant un outil tout indiqué pour ce type de travail, je n'ai pas eu à faire de parallèle 
avec d'autres langages.

En premier lieu, il convient de présenter les structures choisies pour abriter les objets.
Puis, j'expliquerai brièvement la génération du code et les problèmes rencontrés.

\section{Interface des objets}

Un objet Enyo présente 3 grandes parties distinctes :
\begin{itemize}
  \item Les méthodes,
  \item les propriétés,
  \item les événements qu'il est capable de ``capturer''.
\end{itemize}

Pour les méthodes et les propriétés, il est nécessaire de fournir le type à l'IDL pour assurer à
OCaml la sûreté du typage.

Les événements, quant à eux, possèdent un lien vers le type d'événement et les champs qu'il faut préciser.

\begin{OCaml}
type values_rep =  String | Int | Float | Bool | Unit 
		   | Component | Array of values_rep | Dom_node

type method_rep = Method of string * values_rep list

type attributes_rep = Attribute of string * values_rep * bool

type event_rep = Event of string * attributes_rep list

type handler_rep = Handler of string * event_rep

type object_rep = Type of string * method_rep list * attributes_rep list * handler_rep list
\end{OCaml}

On représente alors l'objet Enyo par :
\begin{itemize}
\item Son nom Enyo,
\item une liste de représentation de méthodes,
\item une liste de représentation de propriétés\footnote{L'utilisation du booléen permet de savoir si 
une fonction de type <value>Changed doit être générée. Ceci est, pour l'instant, inutilisé.},
\item une liste des noms d'événements que ce type d'objet est capable de traiter.
\end{itemize}

On obtient ainsi pour l'objet ``Control'' d'Enyo, la représentation suivante :

\begin{OCaml}
Type ("Control",
      [
	Method ("render", [Unit; Unit]);
	Method ("rendered", [Unit; Unit]);
	Method ("renderInto", [Dom_node; Unit]);
	Method ("setBounds", [Int; Int; Int; Int; Unit]);
	Method ("show", [Bool; Unit]);
	Method ("write", [Unit; Unit]);
        (*...*)
      ],
      [
	Attribute ("style", String, true);
	Attribute ("content", String, true);
	Attribute ("allowHtml", Bool, false);
	Attribute ("src", String, true);
        (*...*)
      ],
      [Handler ("ontap", Gesture_event._gesture)]
)
\end{OCaml}

En parcourant l'API fournie sur le site d'Enyo, on peut retranscrire les différentes méthodes 
et propriétés des objets.
Je complète ainsi chaque objet et l'inclus dans un arbre de représentation des objets recréant 
ainsi la hiérarchie de classe Enyo permettant à chaque composant d'hériter des méthodes et attributs.
Il faut maintenant généré le code correspondant à chaque n\oe{}ud de cet arbre.

\section{Générateur de code}

L'objectif de la génération est d'obtenir en sortie un module complet basé sur l'arbre  
représentant la hiérarchie de classe Enyo avec le modèle définit par l'IDL.

Le programme se chargeant de ce travail parcours l'arbre en résolvant les dépendances
entre les différents noeuds.

Par exemple, si l'objet ``Control'' possède une propriété \emph{content}, il convient
de transmettre celle-ci à tous ses fils.
Nous pourrons alors générer dans les constructeurs et les signatures de méthodes
les éléments à prendre en compte.

Prenons en exemple, une petite hiérarchie : une classe \emph{Control} et ses deux fils \emph{Button} et \emph{Input}. 
\emph{Control} implémente uniquement la propriété \emph{content}. Il faut alors générer des constructeurs
acceptant cette propriété en argument, ainsi que les accesseurs/modificateurs engendrés :

\begin{OCaml}
sig
  val control : ?content:string -> unit -> [> `CONTROL ] kind

  val button : ?content:string -> unit -> [> `BUTTON ] kind
  val input : ?content:string -> unit -> [> `INPUT ] kind

  val getContent : [< `CONTROL | `BUTTON | `INPUT ] obj -> string
  val setContent : [< `CONTROL | `BUTTON | `INPUT ] obj -> string -> unit
end
\end{OCaml}

Les constructeurs prennent donc tous bien la propriété en argument optionnel et
Les méthodes générées acceptent correctement les sous-types des classes concernées par cette propriété.

Il suffit de généraliser cette méthode pour obtenir une déclaration correcte de la signature des modules.
Reste à, trivialement, imprimer le corps des fonctions, correspondant à la description faite dans la partie ``interfaçage'',
et les fonctions auxiliaires du module.

%%%%%%%%%%%%%%%%%%
%   CHAPITRE 5   %
%%%%%%%%%%%%%%%%%%


\chapter{Conclusion}

A travers ce projet, nous avons pu établir un certain nombre de choses.
Tout d'abord, nous avons pu établir que le style de programmation d'Enyo nous offrait
un nombre important de possibilités. Il a fallu étudier ce style, son fonctionnement et 
en abstraire les concepts afin de définir un modèle intéressant et cohérent.

La scission de la représentation et de l'instanciation de l'objet Enyo sur lequel j'ai basé mon modèle
répondent à l'objectif de sûreté que nous nous étions fixé tout en assurant un degré important
de liberté vis-à-vis de l'API d'Enyo.

Enfin, la définition d'un IDL a permis une génération fiable de l'implémentation finale mais aussi de 
permettre de tenir à jour l'API Enyo de manière assez aisée en cas de besoin.

Cependant, le rendu final subit quelques défauts : 
\begin{itemize}
\item L'utilisation de variants, bien que permettant 
  une bonne modélisation, peut être perçue comme complexe et empêcher une prise en main rapide. Cela fournit
  également des messages d'erreurs inélégants. 
  Cette dernière remarque s'applique aussi pour l'utilisation des paramètres optionnels lors de la
  construction des objets.
\item L'accession aux différents composants instanciés lors de la définition du traitement 
  des événements n'est pas satisfaisante et gagnerait à être améliorée.
\item L'IDL ne traite pas certains cas particuliers et reste relativement primaire.    
\end{itemize}\medskip

Pour permettre une continuation du projet, il peut-être intéressant de reprendre les problèmes
énoncés avec, par exemple, les différentes approches énoncées dans les différentes sections. Pour résumer :
\begin{itemize}
\item Réfléchir à une représentation différentes que les variants, quitte à rendre le
  module plus lourd, par une approche objet ou type simple.
\item Pouvoir accéder aux instanciations Enyo par le ``kind'' de l'objet, en s'assurant
  de son existence. Par exemple, ainsi :
  \begin{OCaml}
    let bouton_obj = getObj button_kind (* 'a kind -> 'a obj *)
    setContent bouton_obj "Nouvelle valeur"
  \end{OCaml}
\item Il serait bien de compléter la hiérarchie en fournissant des solutions adéquates
  aux cas particuliers. Ensuite, pouvoir fournir des possibilités d'extension à l'IDL en permettant 
  des définitions internes de composants. Par exemple, être capable  de créer un nouvel objet ``ChampValidation'' 
  possédant deux composants ``Input'' et ``Button'' ainsi qu'une fonction de validation.
\item Il faudrait réfléchir à une représentation des n\oe{}uds du DOM. Est-ce que l'on souhaite passer 
  par ``js\_of\_ocaml'', fournir une chaine le représentant, ou encore définir quelques n\oe{}uds principaux
  et brider leur utilisation?
\end{itemize}\medskip

Sur le plan personnel, ce stage m'a été, je pense, très profitable ; j'ai pu consolider mes bases en OCaml
ainsi que mon engouement pour ce langage. Je le dois en bonne partie à l'équipe capable et dynamique
dont j'ai eu la chance d'être entouré pendant ces deux mois.
De plus, cette expérience au sein d'un laboratoire m'a sérieusement fait réfléchir à 
une éventuelle formation vers la recherche.
Je me satisfais donc d'avoir pu effectuer ce stage dont j'en sors enrichi.

\chapter{Annexes}

\section{Hiérarchie complète Enyo}\label{hier-complet}

\lstinputlisting[basicstyle=\tt]{arborescence.txt}

\section{Déploiement d'applications}

Le déploiement d'applications sur les différentes plateformes nécessite quelques changements mineurs 
de l'application en fonction de la cible visée.

Tout d'abord, Enyo fournit un ``bootplate'' décrivant l'organisation standard d'une application.
Ce dossier contient un script ``deploy'' permettant de préparer l'application au 
déploiement ainsi que l'analyse du programme et la suppression des fichiers inutilisés.

A partir de là, pour un déploiement sur tablette HP, par exemple, il est nécessaire d'obtenir les outils
développeur de la tablette permettant de ``packagé'' l'application.
Pour un déploiement sur téléphone (``android'', ``iOs'', etc.), il est nécessaire de télécharger
``PhoneGap'' \url{http://www.phonegap.com/developer} qui propose ce genre de ``packaging''.
Il est toutefois nécessaire de fournir un n\oe{}ud \emph{meta} dans le document Html principal de l'application
selon la plateforme.
Les détails sont accessibles à cette adresse : \\
\url{https://github.com/enyojs/enyo/wiki/Platform-Specific-Deployment}

\section{Exemples de programme}

Les exemples d'applications se situent dans le dossier ``exemples'' à la racine du projet.

On pourra y trouver quelques applications JavaScript ainsi que des jeux utilisant la bibliothèque inspiré des exemples contenu sur le cédérom 
du manuel ``DAOC''\cite{DAOC}.

\tableofcontents
\nocite{*}
\bibliographystyle{plain}
\bibliography{biblio}

\end{document}
